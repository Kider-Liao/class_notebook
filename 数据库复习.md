#### 第一章

1. 逻辑层、物理层、实例

   ![image-20220102203858584](C:\Users\pentakill\AppData\Roaming\Typora\typora-user-images\image-20220102203858584.png)

2. 物理、逻辑数据独立性

   ![image-20220102204040411](C:\Users\pentakill\AppData\Roaming\Typora\typora-user-images\image-20220102204040411.png)

​		数据在物理层上(硬盘等位置)的修改不会影响到其逻辑层的结构；即使很小的逻辑结构在物理层上的表示十分复杂，逻辑层也不需要考虑其在物理层上的表示

3. DDL & DML

   DDL：用于定义数据的存储和含义，定义了数据库模式和特征，包括关系模式、属性的域和类型、完整性约束、数据索引、数据库权限、数据库的物理布局

   DML：数据操纵语言，帮助用户查询、插入、更新和删除数据库中的数据，声明式DML只需要用户说明需要什么数据，而过程式DML需要用户说明需要的数据和调用数据的方式

   ![image-20220103204059390](C:\Users\pentakill\AppData\Roaming\Typora\typora-user-images\image-20220103204059390.png)

4. 数据字典是包含了DDL语言的输出，也包含了元数据(数据库模式、参照完整性、授权)的，由数据库系统进行维护和修改的一个特殊的表；元数据是指描述数据的数据，是对数据和信息资源的描述性信息，记录了数据的性质和特征

5. 完整性约束包括了：值域约束、参照完整性(主码、外码)、断言(assertion)、授权

6. 数据库设计：

   逻辑设计：设计数据库的关系模式

   物理设计：设计数据库的存储方式等



#### 第二章

1. 术语：

   关系：数据库中的表

   元组：表中的行

   属性：表中的列

   关系实例：关系中包含的一组特定的行

   数据库模式：数据库的逻辑设计

   数据库实例：特定时刻数据库的快照

   关系模式：关系由特定属性以及对应的域组成

   超码：一个属性或多个属性的集合，这些属性的组合能够唯一的标识一个元组

   候选码：任意真子集不能成为超码的超码

   主码：由用户决定的候选码，与超码、候选码定义了整个关系中的性质；主码不能为空值

   外码：一个关系中包含的另一个关系的主码，包含方称作参照关系，被包含方称作被参照关系

2. 关系代数

   选择运算σ θ(relation)：筛选relation中满足θ条件的元组

   投影运算Π θ1,θ2(relation)：筛选relation中的θ1、θ2属性；进阶的投影运算可以对属性进行运算，得到想要的属性值，例如<img src="C:\Users\pentakill\AppData\Roaming\Typora\typora-user-images\image-20220103154540770.png" alt="image-20220103154540770" style="zoom:50%;" />。该操作会去除重复元组

   笛卡尔积×：两个relation中的所有元组进行全排列组合，由于两个relation可能有相同的属性名，因此需要增加上relation的名字进行区分

   join运算⋈θ：<img src="C:\Users\pentakill\AppData\Roaming\Typora\typora-user-images\image-20220103160946974.png" alt="image-20220103160946974" style="zoom:50%;" />

   集合运算∩、∪、—：运算采用的属性数量和相应的类型需要相同

   赋值运算←：将某个关系表赋值给某个变量

   重命名运算ρx(E)：将关系实例E命名为x；进阶的命名运算给每个属性新的名字，例如<img src="C:\Users\pentakill\AppData\Roaming\Typora\typora-user-images\image-20220103162133472.png" alt="image-20220103162133472" style="zoom:50%;" />将属性名更改为A1、A2等

   

#### 第三章

1. 数据库的定义包含：关系模式、数据的域和类型、完整性约束、索引、关系的权限信息、关系的存储结构

2. numeric(p,d)数据类型：只能存储含有p位数字的数，其中小数有d位

3. 数据库模式的定义：

   <img src="C:\Users\pentakill\AppData\Roaming\Typora\typora-user-images\image-20220103205838952.png" alt="image-20220103205838952" style="zoom:50%;" />

   其中foreign key的引用属性需要是另一个表的主码

4. 为关系增加属性、去除属性(所有已存在的元组在增加的属性上为NULL)

   <img src="C:\Users\pentakill\AppData\Roaming\Typora\typora-user-images\image-20220103210357275.png" alt="image-20220103210357275" style="zoom:50%;" />

   <img src="C:\Users\pentakill\AppData\Roaming\Typora\typora-user-images\image-20220103210409311.png" alt="image-20220103210409311" style="zoom:50%;" />

5. 查询中去除重复元组采用distinct，它添加在select语句和属性之间，只需要一个distinct即代表去重

6. select语句中的属性允许添加加减乘除等运算，属性可以为一个常量

7. 字符串运算：

   like语句可以进行字符串的模式匹配(SQL标准对字符串的大小写是敏感的)

   <img src="C:\Users\pentakill\AppData\Roaming\Typora\typora-user-images\image-20220103215644618.png" alt="image-20220103215644618" style="zoom:50%;" />

8. 排列元组显示次序：order by语句，其中desc表示降序，asc表示升序

9. where语句中可以用between……and……代表小于等于加大于等于的对比，可以进行元组的对比

10. 集合间的操作：并运算union，交运算intersect，差运算except；这些运算会自动去除重复，不去除的话要在后面加上all，如union all；特别地，A except all B中，结果重复元组数相当于A的重复元组数减去B的重复元组数

11. 空值：空值NULL的算数运算仍为空值；NULL比较运算的结果为unknown(包括null = null这类)，特别对于布尔运算，有

    <img src="C:\Users\pentakill\AppData\Roaming\Typora\typora-user-images\image-20220103222339001.png" alt="image-20220103222339001" style="zoom:50%;" />

12. 聚集函数：

    avg：求整个集合特定属性的平均值(计算平均值时保留重复元素很重要)

    <img src="C:\Users\pentakill\AppData\Roaming\Typora\typora-user-images\image-20220103223043457.png" alt="image-20220103223043457" style="zoom:50%;" />

    count：求集合的元组数量

    min：求集合中特定属性的最小值

    max：求集合中特定属性的最大值

    sum：求集合中特定属性的和

    

    除了count(\*)之外的聚集函数都忽略null值，如果所有属性值都为null则返回null(count返回0)

13. 分组聚集：where筛选后用group by进行分组；select中没有被聚集的属性(调用聚集函数)必须是出现在group by中的属性；分组聚集后可以用having进行特定条件的筛选，出现在having中的没有被聚集的属性必须出在group by中；group by适合用于做统计，而不适合用来将具有同个属性的元组放一起，放一起应该用order by

14. 集合嵌套：

    in：检验某个属性是否在某个集合中

    \> some：某个集合存在比该属性小的属性值(其它比较运算符类似)

    \> all：某个集合所有属性都比该属性值小

    exists：检验某个集合是否为空

    **unique：检验某个集合是否包含重复元组(空集也返回true)**

    with子句：创建一个临时的表，减小代码长度；with……as()……

    关注标量子查询的运用：P53末尾

    集合的包含关系可写为<img src="C:\Users\pentakill\AppData\Roaming\Typora\typora-user-images\image-20220103231409307.png" alt="image-20220103231409307" style="zoom:50%;" />

15. 数据库修改：

    删除：delete from relation where；没有where时删除所有元组；一个delete语句只能删除一个关系中的元组(注意删除后where的一些判定可能会改变，如表的平均值会改变)

    插入：insert into relation values或insert into relation (select……)，后者表示将查询语句得到的所有结果都加入关系中；在执行插入之前会先获得查询语句得到的结果

    更新：update relation set…… where……；update后给relation改名不需要用as；更新中set后可以调用case语句，根据情况进行更新，case语句形如(select中也可以用case语句)

    <img src="C:\Users\pentakill\AppData\Roaming\Typora\typora-user-images\image-20220103234416620.png" alt="image-20220103234416620" style="zoom:50%;" />

#### 第四章

1. 自然连接natural join：筛选出两个关系笛卡尔积中共同属性相同的元组，且不会重复列出共同的属性，列举顺序为共同属性、第一个关系的属性、第二个关系的属性。自然连接的结果与关系之间的共同属性相关，需要注意同名的属性的存在；为了避免自然连接用了额外的属性进行拼接，可以采用join……using语句进行代替，using同样也不会重复两者的共同属性；join……on后面增加表达式，表示连接方式，与where类似，它会**重复两者的共同属性**

2. 外连接(没有匹配的元组的对应属性为null)：

   <img src="C:\Users\pentakill\AppData\Roaming\Typora\typora-user-images\image-20220104095059564.png" alt="image-20220104095059564" style="zoom:50%;" />

   外连接中的on和using与where的效果是不同的，因为using和on会补上NULL值，而where是对join得到的结果进行条件的判断；outer join可以通过natural join的结果union缺失的结果来代替

3. 视图定义：<img src="C:\Users\pentakill\AppData\Roaming\Typora\typora-user-images\image-20220104100715546.png" alt="image-20220104100715546" style="zoom:50%;" />视图只在概念上包含查询结果中的元组，但并不进行预计算和存储(在需要时会运行对应的查询语句获得结果)

   <img src="C:\Users\pentakill\AppData\Roaming\Typora\typora-user-images\image-20220104101202622.png" alt="image-20220104101202622" style="zoom:50%;" />

   物化视图：将视图实际存储在数据库。如果参照的表有修改，视图也需要进行视图维护。物化视图可以提高查询视图的效率，但是需要与存储代价跟更新开销进行权衡

4. 视图通常是不可更新的，因为它会造成参照的表中的歧义，除非它满足以下条件

   <img src="C:\Users\pentakill\AppData\Roaming\Typora\typora-user-images\image-20220104102030010.png" alt="image-20220104102030010" style="zoom:50%;" />

   这种更新有可能因为where的筛选导致插入了参照表中而没插入视图中，视图定义末尾增加with check option则会判断是否能插入视图中，不能则报错

5. 完整性约束

   not null：不允许某个属性值为NULL

   unique(A1,A2,A3)：对应属性集合为候选码

   check子句：自定义约束

   参照完整性约束references：关系中的某个属性集取值需要在另一个关系的对应属性集取值中出现。外码中的属性允许为null；参照属性的名字不一定相同，但是类型一定相同；参照完整性的更新通常拒绝破坏完整性约束的操作，也可能是on delete cascade(级联删除)、set null(设为空值)、set default(设为默认值)

   为约束命名：在约束前添加constraint+名字 <img src="C:\Users\pentakill\AppData\Roaming\Typora\typora-user-images\image-20220104110447132.png" alt="image-20220104110447132" style="zoom:50%;" />

   事务中可能短时间违反完整性约束，用语句initially deferred或set constraint constraint-list deferred使得约束在事务结束时检查

   断言assertion：<img src="C:\Users\pentakill\AppData\Roaming\Typora\typora-user-images\image-20220104111305787.png" alt="image-20220104111305787" style="zoom:50%;" />创建断言时会检查其有效性，且以后对数据库的任何修改都必须满足断言

6. 自定义数据类型：create type……as……，自定义出来的类型是强类型的(不能与参照的类型进行比较)

   自定义域：create domain……as……，域的定义中可以添加约束，域不是强类型的

7. 索引的创建：create index \<index-name> **on** \<relation-name> (\<attribute-list>)

8. 权限

   授权指令：grant \<权限列表> on \<关系或视图名> to \<用户\角色列表>；update、insert权限可以被授予在表上，也可以被授予在某个属性上(insert被授予在属性上时，未授权属性设置为null或默认值)；public类型代表了所有用户；模式等对象的拥有者拥有它们的所有权限

   收回权限：revoke \<权限列表> on \<关系或视图名> from \<用户\角色列表>；若收回权限中包括public，则会收回除了显式授权的用户外的所有用户的权限

   角色的概念：create role……；角色可以被授予权限，被授予权限后，扮演这些角色的用户就能得到对应的权限；角色可以授予给用户，也可以授予给其它角色；因此，一个用户或角色拥有的权限为它被授予的权限以及它扮演的角色拥有的权限；授权可以由一个角色来完成，通过set role语句设置当前会话的角色，granted by current_role通过当前角色进行授权(这可以防止级联收回而导致不必要的权限收回)

   视图的授权：创建视图的用户必须拥有参照的表的select权限；获得视图的权限的用户不需要拥有参照的表的对应权限

   模式的授权：只有数据库模式的拥有者才能进行对模式的任何修改；P83 references权限的应用

   权限的转移：在授权时增加上with grant option，则能允许被授权者再将权限授予其他用户；用户的授权关系形成了授权图；用户具有某个权限的充分必要条件是：当且仅当存在从根到代表该用户的结点的路径

   权限的收回：默认情况下，权限是级联收回的，可以在revoke中申明restrict防止级联收回(如果存在级联收回则会报错，而不是只收回一个)；revoke权限时要根据授权图进行，如果有两个及以上的用户授予了某个用户权限时，仅仅删除一次该用户的权限可能不足以解除他的权限；可以只收回grant option<img src="C:\Users\pentakill\AppData\Roaming\Typora\typora-user-images\image-20220104123240123.png" alt="image-20220104123240123" style="zoom:50%;" />



#### 第五章

1. JDBC、ODBC中可以调用预置语句保证语法的正确性以及避免mysql注入攻击P91

2. 函数创建：

   <img src="C:\Users\pentakill\AppData\Roaming\Typora\typora-user-images\image-20220104155726735.png" alt="image-20220104155726735" style="zoom:50%;" />

   表函数定义(返回值为一个表的函数)：

   <img src="C:\Users\pentakill\AppData\Roaming\Typora\typora-user-images\image-20220104155842796.png" alt="image-20220104155842796" style="zoom:50%;" />

   过程创建：

   ![image-20220104160119992](C:\Users\pentakill\AppData\Roaming\Typora\typora-user-images\image-20220104160119992.png)

3. 触发器：触发器是更新数据库时由系统自动调用的语句，产生更新数据库的副作用

3. 触发器定义：

   <img src="C:\Users\pentakill\AppData\Roaming\Typora\typora-user-images\image-20220104161430462.png" alt="image-20220104161430462" style="zoom:50%;" />

   delete/insert on table



#### 第六章

1. **数据库设计的五个步骤**：

   - 数据需求分析：完整地刻画和描述用户数据需求
   - 概念结构设计：使用实体-联系模型(数据模型)对用户需求进行转化，转化为数据库的概念模式
   - 功能需求说明：根据用户的功能需求完善概念模式
   - 逻辑结构设计：将概念模式映射到数据库模型上，确定数据库模式
   - 物理结构设计：将数据模型通过特定的物理存储结构进行存储(确定物理布局)

2. 数据库设计需要避免的两大缺陷

   冗余：在设计过程中重复了信息，如每次开课都重复课程信息。这存在的问题是某个课程信息修改，则其它所有有关的课程信息都要修改，否则会导致一致性的问题

   不完整性：数据库设计上存在缺漏，导致某些信息无法表示

3. 实体-联系模型(E-R模型)：

   实体：现实世界可区别于其它对象的独立对象，实体由一组属性来表示

   实体集：具有相同类型和相同性质的实体的集合

   联系：多个实体之间的关联关系，联系可以具有描述性属性，表示该联系的相关属性

   联系集：相同类型的联系的集合，参与联系集的实体集的数量称为联系集的度；实体集可以以某种角色参与联系集，这使得实体集在联系集中能被区分(特别是与自身联系的实体集)

4. 属性类型

   简单\复合属性：简单属性不可划分为更小的部分，复合属性可由多个简单属性和复合属性构成，这些属性称为复合属性的子属性

   单值\多值属性：单值属性只有某个特定的值；多值属性可以有不同数量的值，通常用大括号框住表示多值属性，如{phone_number}

   派生属性：某些属性可以从其它属性的值派生出来

5. 映射基数(A和B的关系举例)

   一对一：A实体集中的实体至多与B的一个实体进行关联，B的实体也至多能与A的一个实体关联

   一对多：A实体集中的实体能与任意个(包括0)B的实体进行关联，B的实体至多与一个A的实体关联

   多对一：B实体集中的实体能与任意个A的实体进行关联

   多对多：A、B中的实体都能与对方任意个实体进行关联

6. 参与约束

   全参与：实体集中的所有实体都参与到某个联系中

   部分参与：实体集中存在不参与到某个联系中的实体

7. 联系的属性：

   <img src="C:\Users\pentakill\AppData\Roaming\Typora\typora-user-images\image-20220104175651450.png" alt="image-20220104175651450" style="zoom:50%;" />

   其中所有联系的实体集的主码的并集构成了联系集中的超码；

   联系集的主码结构依赖于映射关系：如果映射关系是多对多的，则主码由两个实体集的主码的并集组成；如果映射关系是一对多或多对一的，则主码由多的那个实体集的主码组成；如果映射关系是一对一的，则主码由任意一个实体集的主码组成

8. 实体集的设计需要主要去除冗余属性，即两个相联系的实体集通常没有相同的属性

9. E-R图的主要构件：

   分成两部分的矩形表示实体集，上矩形为实体集名字，下矩形包含实体集属性

   菱形表示联系集，联系集的属性用一个矩形表示，用虚线与联系集相连

   线段将实体集与联系集连接，有箭头的一方表示该实体集映射为一，无箭头表示该实体集映射为多映射；双线表示该实体集全参与到联系集中；

   双菱形表示连接到弱实体集的联系集，双矩形表示弱实体集，弱实体集的分辨符用下划虚线表示

   通过基数约束，可以定义实体集的映射基数，其中\*表示无穷，左边的数为下限，右边的数为上限。需要注意这个与一对多、多对一表示上的区别。例如下面表示的是instructor 一对多 student

   <img src="C:\Users\pentakill\AppData\Roaming\Typora\typora-user-images\image-20220104192946755.png" alt="image-20220104192946755" style="zoom:50%;" />

   复合属性的表示为：先写出复合属性的名字，再列出其子属性的名字，如

   <img src="C:\Users\pentakill\AppData\Roaming\Typora\typora-user-images\image-20220104195902556.png" alt="image-20220104195902556" style="zoom:50%;" />

   多值属性用大括号括住表示，如{phone_number}；派生属性后要加上括号，如age()

   通过在菱形和矩形之间的连线上进行标注来表示角色

   注意：在一个非二元联系集外，我们至多能有一个箭头

10. 弱实体集：没有足够属性构成主码的实体集称为弱实体集。弱实体集必须与另一个称作标识或宿主实体集的实体集关联才具有它的意义，即它的存在依赖于标识实体集；弱实体集与标识实体集之间的联系称为标志性联系，它是从弱实体集到标志实体集多对一的，且弱实体集的参与度是全参与；弱实体集的主码由它的分辨符以及标识实体集的主码构成(即分辨符是主码除去标志实体集的主码的剩余部分)

11. 关系模式转换

    具有简单属性的强实体集：直接将实体集的属性和主码等转化为关系模式的属性和主码即可

    具有复杂属性的强实体集：对于复合属性，我们为每个子属性创建一个单独的属性，而不再为复合属性本身创建属性；多值属性需要为其创建一个新的关系模式，以多值属性和父实体集的主码作为新的关系模式的主码，并在新的关系模式上引入外码约束，参照父实体集的主码；如果某个实体集只包含主码和一个对应的多值属性，则可以直接用为多值属性创建的关系模式表示这个实体集；派生属性不在关系模式中表现；

    弱实体集：在实体集包含的属性的基础上，增加标志实体集的主码作为其关系模式的属性，以分辨符加获得的主码作为其关系模式的主码，并增加参照标识实体集对应的关系模式的外码约束

    联系集：在联系集拥有的属性的基础上，考虑多种情况。

    - 主码的确定：对于多对多的二元联系，以两个实体集的主码的并集作为联系集关系模式的主码，创建一个新的关系模式；对于多对一、一对多的二元联系，以多的一方的实体集的主码作为关系模式的主码；对于一对一的二元联系，任取一方实体集的主码作为关系模式的主码；对于无箭头的n元联系，所有参与实体集的主码属性的并集成为主码；对有一个箭头的n元联系，无箭头的参与实体集的主码属性的并集称为主码
    - 模式的合并：对于多对一的联系，联系可以并入到多的一方的实体集的关系模式中，如果不是全参与则可以用null值来表示；对于一对一的联系，联系可以并入到任意一方的实体集的关系模式中；对于多对多的联系，需要为联系创建一个新的关系模式

12. 扩展E-R特性

    特化：在实体集内部进行分组的过程称为特化。实体集包含子集，子集中的实体具有区别于其他实体的属性(子实体集中包含父实体集中没有的属性)。重叠特化允许一个实体集的实体属于多个特化实体集(一个person即能是一个student又能是一个employee)，不相交特化允许一个实体集的实体·至多属于一个特化实体集(一个person至多是student和employee的其中一个)。重叠特化分开的空白箭头表示，不相交特化用一个箭头表示，例如

    <img src="C:\Users\pentakill\AppData\Roaming\Typora\typora-user-images\image-20220104212829232.png" alt="image-20220104212829232" style="zoom:50%;" />

    特化通过创建不同较低层的实体集来强调同一实体集中不同实体的差异

    概化：两个实体集的共性(包含相同的属性)形成父实体集称为概化。高层实体集称为超类，底层实体集称为子类；概化通过实体集间的共性综合成一个高层实体集，强调低层实体集的相似性并隐藏它们的差异

    高层实体集与底层实体集的关系：高层实体集拥有的属性和联系适用于它的所有低层实体集、低层实体集具有的性质只适用于特定的低层实体集；低层实体集可能多继承地参与到多个ISA联系中，这种实体集称作格

    完全性约束：全部概化要求每个高层实体必须属于一个低层实体集；部分概化允许一些高层实体不属于底层实体集；全部概化在表示中需要加上total关键词，并用一个虚线指向对应的箭头

    <img src="C:\Users\pentakill\AppData\Roaming\Typora\typora-user-images\image-20220109210349636.png" alt="image-20220109210349636" style="zoom:50%;" />

    P169 P171 实体集聚集需要关注一下

13. 扩展的E-R特性转化为关系模式

    概化、特化的表示：为每个高层实体集创建一个关系模式，包括了高层实体集的所有属性。为每个低层实体集创建一个关系模式，包含了高层实体集的主码以及低层实体集特有的属性，并建立低层关系模式参照高层关系模式的外码约束；如果概化、特化是不相交且完全的，则可以将高层实体集的属性添加到低层关系模式中，并去除高层关系模式

    <img src="C:\Users\pentakill\AppData\Roaming\Typora\typora-user-images\image-20220104220630918.png" alt="image-20220104220630918" style="zoom:50%;" />



#### 第七章

1. 有损分解：对某个关系模式进行分解后，用自然连接重新生成原始元组时造成了信息的丢失(如无法确定哪个人对应了哪条信息)；如果自然连接后能得到原来的关系模式，则是无损分解

2. 原子域：一个域的元素是不可分的单元，称之为原子域

   第一范式：关系模式中所有属性的域都是原子的

3. 函数依赖

   定义：对于关系模式r(R)上的实例的所有元组对t1和t2，满足若t1[α] = t2[α]，则t1[β] = t2[β]，则称实例满足函数依赖α->β；若每个合法实例都满足该函数依赖，则称函数依赖在关系模式r(R)上成立

   函数依赖闭包：所有隐含在函数依赖集F中的函数依赖的集合，用F+表示；F+包含了F的所有函数依赖

   判断分解为无损的(二元分解的充分条件，全部依赖为函数依赖时为必要条件)：将R分解为R1和R2，如果R1∩R2形成了R1或R2的一个超码，则称这个分解是无损的

4. 函数依赖理论

   Armstrong公理：

   - 自反律：若α为一属性集且β属于α，则α->β成立
   - 增补律：若α->β成立，γ为一属性集，则γα->γβ成立
   - 传递律：若α->β和β->γ成立，则α->γ成立

   推广规则：

   - 合并率：若α->β且α->γ，则α->βγ
   - 分解率：若α->βγ，则α->β且α->γ
   - 伪传递率：若α->β和γβ->δ成立，则αγ->δ

   F+计算算法：

   - <img src="C:\Users\pentakill\AppData\Roaming\Typora\typora-user-images\image-20220106170415849.png" alt="image-20220106170415849" style="zoom:50%;" />

   属性集的闭包：属性集α的闭包用α+表示，表示属性集α在函数依赖F下能够确定的属性集。属性闭包可以用于检验超码、检查函数依赖、计算F+。属性集的闭包计算算法为(注意不需要用F+)

   <img src="C:\Users\pentakill\AppData\Roaming\Typora\typora-user-images\image-20220106171117959.png" alt="image-20220106171117959" style="zoom:50%;" />

   正则覆盖：

   - 属性无关的概念：如果去除函数依赖中的一个属性不改变函数依赖集的闭包，则称该属性是无关属性；若A属于α且F逻辑蕴含α->β去除A后的依赖集F\`，则A在α中无关；若A属于β且α->β去除A后的依赖集F\`逻辑蕴含F，则A在β中无关

   - 属性无关的判定：如果A属于β，则判断去除A后的依赖集F\`中是否能够推出α->A，即F\`中α+包含A；如果A属于α，则判断原依赖集是否能推出(α-A)->β，即F中(α-A)+包含β

   - 正则覆盖：用Fc表示，F和Fc互相逻辑蕴含；Fc中不包含无关属性；Fc中的左半部都是唯一的

     <img src="C:\Users\pentakill\AppData\Roaming\Typora\typora-user-images\image-20220106174636660.png" alt="image-20220106174636660" style="zoom:50%;" />

   依赖保持：

   - 定义：如果数据库的任一函数依赖可以在某一个关系中直接验证，则认为数据库的关系模式是依赖保持的

   - 限定的概念：令Ri是R的一个分解，F在Ri上的限定是指F+中所有只包含Ri中的属性的函数依赖的集合Fi

   - 依赖保持的判定：

     (复杂方法)对于所有分解中的限定，它们的并集等于F+；

     (充分但不必要条件)如果F中的任一函数依赖都可以在分解得到的某一关系上验证，那么这个分解依赖保持；

     (更优方法)对于F中任一函数依赖α->β，若下述算法的结果包含β的所有属性，则α->β依赖保持(每个属性闭包都是在F下计算)

     <img src="C:\Users\pentakill\AppData\Roaming\Typora\typora-user-images\image-20220106182008473.png" alt="image-20220106182008473" style="zoom:50%;" />

5. BC范式

   定义：对于F+中的所有形如α->β的函数依赖，要么其为平凡的函数依赖，要么α是R的一个超码，那么该关系模式属于BCNF

   关系模式R分解为BCNF：若R由于函数依赖α->β中，α不是R的超码，导致其不是BCNF，则可以用α∪β以及(R - β)两个模式取代R，其中α∩β为空；进行多次这种分解后，能得到一个BCNF模式的集合。分解依据为F+

   <img src="C:\Users\pentakill\AppData\Roaming\Typora\typora-user-images\image-20220106193236343.png" alt="image-20220106193236343" style="zoom:50%;" />

   BCNF的判定方法：对于Ri中属性的每个子集α，确保α要么不包含Ri-α的任何属性，要么包含其中的所有属性

6. 第三范式

   定义：对于F+中的所有形如α->β的函数依赖，要么其为平凡的函数依赖，要么α是R的一个超码，要么β-α中每个属性A都包含在R的一个候选码中(可以是不同候选码)，那么该关系模式属于第三范式；3NF的条件确保每个模式都有依赖保持的3NF分解

   3NF分解(比较抽象，注意用的是Fc)：

   <img src="C:\Users\pentakill\AppData\Roaming\Typora\typora-user-images\image-20220106194658454.png" alt="image-20220106194658454" style="zoom:50%;" />

7. 数据库设计的三个目标：关系模式属于BCNF，关系模式属于无损分解，依赖保持

7. BCNF与3NF比较：3NF总能保证无损分解以及依赖保持；3NF可能造成信息冗余，而且需要用NULL值来替代某些没有的信息

8. 多值依赖：表示为α->->β，若r中一对满足t1[α] = t2[α]的元组对t1和t2，r中都存在元组t3和t4，使得

   <img src="C:\Users\pentakill\AppData\Roaming\Typora\typora-user-images\image-20220106201828213.png" alt="image-20220106201828213" style="zoom:50%;" />

   多值依赖的规则：若α->β，则α->->β；若α->->β，则α->->R-α-β

   D+在某个子关系Ri上的限定包含了D+中所有只含Ri中的属性的函数依赖以及所有形如α->->(β∩Ri)的多值依赖(α需要在Ri中)

9. 4NF：对D+(关于函数依赖和多值依赖的闭包)中所有形如α->->β的多值依赖，要么这是一个平凡的多值依赖(β属于α或α∪β=R)，要么α是R的一个超码；4NF的分解与BCNF基本相同

10. 基于多值依赖的无损分解：若R的分解R1和R2满足R1∩R2->->R1或R1∩R2->->R2属于D+，则称该分解为无损分解

![image-20220110125502342](C:\Users\pentakill\AppData\Roaming\Typora\typora-user-images\image-20220110125502342.png)

#### 第十章

1. 一个磁盘扇区通常为512个字节，扇区是读出和写入信息的最小单位

2. 磁盘通过读写头进行读写，由磁臂进行读写头的移动，为了增加存储密度，读写头与盘片非常接近

3. **磁盘性能由访问时间、容量、数据传输率和可靠性度量**；访问时间包括寻道时间、旋转等待时间(待盘片转到对应的扇区)、数据读取时间。寻道时间通常依据平均寻道时间，旋转等待时间依据平均旋转等待时间

4. 磁盘访问优化：利用缓存、利用预读、进行磁盘IO请求调度、优化文件组织、非易失性写缓冲区、日志磁盘(这个可以再看看)

5. NOR是按字节读取、NAND是按页读取；闪存具有更快的随机读取速度，但是传输速率慢。闪存的更新需要将原来的页面擦除再重写，通常会直接写在其他页面，并标记原来的页面为可擦除，因此需要用一个转换表进行逻辑地址到物理地址的转换。

6. 定长记录存储：为每条记录分配它最大可能用的空间，并且不允许记录越过文件中的块；在文件的开始处，需要分配一定字节作为文件头，存储第一块空闲位置的地址。接下来，第一块空闲位置存储下一块空闲位置的地址，以此类推，形成空闲列表。插入数据时，我们使用文件头指向的空闲位置，并让其指向下一个空闲位置

7. 变长记录表示：变长记录通常分为定长属性和变长属性两部分存储，其中对于变长属性，在记录的开始部分存储一个(偏移量，长度)对，指示变长属性的起始位置和长度，再在之后存储变长属性。变长记录存储中同时也要维护一个空位图null bitmap，用来指示哪个属性是空值。空值不进行存储。一个变长记录存储的例子为

   <img src="C:\Users\pentakill\AppData\Roaming\Typora\typora-user-images\image-20220105170229393.png" alt="image-20220105170229393" style="zoom:50%;" />

   变长记录在块中存储：分槽页结构用于变长记录在块中的存储。每个块有个块头，存储了块中的记录数量、块中空闲空间的末尾指针(因为数据存储从块的尾部开始连续排列)、一个包含由记录位置和大小组成的记录条目构成的数组。从尾部开始分配空间的方式避免了块头初始分配空间不足或过大的问题。若某个记录被删除，则需要将该记录的记录条目标记为删除状态，并将记录前面的记录后移，保证空闲空间在最后一条记录和块头尾部之间，同时空闲空间的末尾指针也需要进行修改。分槽页结构要求不能有直接指向记录的指针，指针需要指向块头对应的记录条目

   <img src="C:\Users\pentakill\AppData\Roaming\Typora\typora-user-images\image-20220105174319279.png" alt="image-20220105174319279" style="zoom:50%;" />

8. 文件组织结构

   堆文件组织：一个记录可以放在任何地方，只要有位置就可以存放；记录被放置后通常不会被移动，并且维护每个块中的空闲空间。多数数据库用一个free-space map来维护每个块中的空闲空间，这个结构通常用一个数组表示，数组中的每个条目对应一个块，其中条目记录了块中空闲空间的百分比。若一个条目为3位，则该块剩余空间的百分比至少为存储的值/8；对于更大的数据库，可以用多级map来维护空闲空间，多级map中每个条目记录的是这组空闲空间中空闲最大的块剩余空间的百分比

   顺序文件组织：记录根据搜索码进行顺序存放(搜索码是一个属性或属性集合)；为了便于插入和删除记录，在记录的后面添加指针，指向下一条记录；数据的插入通过将记录放置在当前块的空闲位置或溢出块中，并调整对应的指针；数据的删除修改记录指针即可；根据负载，定时重排记录，使之维持记录的顺序性

   <img src="C:\Users\pentakill\AppData\Roaming\Typora\typora-user-images\image-20220105190729799.png" alt="image-20220105190729799" style="zoom:50%;" />

   散列文件组织：在每条记录的某些属性上计算散列函数，散列函数的结果确定了记录放置在哪个块

   多表聚簇文件组织：在每个块中存储多于一个关系的相关记录的文件结构，允许我们使用一次读取块操作来读取满足连接条件的记录，有助于提升特定查询的效率

9. 数据字典存储：关系的关系模式及其他元数据(数据的数据)存储在数据字典中，数据字典需要存储的内容包括 关系的名字、关系的属性名、属性的域和长度、数据库上定义的视图的名字、完整性约束，可能还会存储授权用户的名字、账户信息等，以及其它各类信息。数据字典通常以非规范化的方式存储，以便提高存取效率

10. 缓冲区中，当某个块被读写时，它需要被固定在缓冲区中而不能被逐出；当某个块提前写回磁盘时，它应当能获得share锁而不被更新

11. 缓冲区替换策略

    LRU：替换最长时间未被访问的块

    MRU：替换最近被访问的块

12. 面向列的存储

    优势：减少了IO数量(对于只访问部分属性的查询)、利于向量化运行、提升Cache的性能

    缺点：增加了元组重建的开销、增加了更新和删除的开销(需要逐个文件查找)、增加了分解的开销



#### 第十一章

1. 索引性能的评判：访问类型(能有效支持的访问类型，如范围查找或特定记录查找)、访问时间、插入时间、删除时间、空间开销

2. 顺序索引：顺序索引按顺序存储搜索码的值，并将搜索码与包含该搜索码的记录关联起来(用指针等方式)。索引项由一个搜索码值以及指向该搜索码值的一条或多条记录的指针构成，该指针包括对应磁盘块的标识和记录的块内偏移量

   如果包含记录的文件中记录按某个特定搜索码的顺序进行排序，则该搜索码称为聚集索引或主索引；搜索码顺序与记录存储的顺序不一致的索引称为辅助索引或非聚集索引；按某个搜索码顺序进行存储且在搜索码上有聚集索引的文件称为索引顺序文件

   稠密索引：文件中每个搜索码值都有一个索引项，它包含了搜索码值以及具有该搜索码值的记录的指针(聚集索引则只需要第一条记录的指针即可)；稀疏索引：只为部分搜索码建立索引项，只能用于聚集索引。查找时找到小于等于目标索引码的最大索引码，再按序找到需要的记录。一个常用的权衡稠密和稀疏索引的方法是为每一个块的记录建立一个稀疏索引

3. 顺序索引更新

   对于数据项插入

   - 如果采用稠密索引，我们观察搜索码值是否在索引中。如果不在，则在索引中的合适位置插入对应的索引项；如果在，则判断索引是否为聚集索引，若是聚集索引则将记录插入到具有相同搜索码值的其他记录之后，否则只需要在索引项中增加一个指向该记录的指针即可
   - 如果采用稀疏索引，假设为每个块保存一个索引项。如果由于该记录的插入导致系统创建了新的块，则新的块的第一条记录的搜索码值将会加到索引中。如果新插入的记录的搜索码是当前块中最小的，则将当前块的索引项的搜索码修改为该记录的搜索码，并指向该记录

   对于数据项删除

   - 如果采用稠密索引，如果该记录是其搜索码对应的唯一一条记录，则删除对应的索引项即可；否则判断该记录对应的指针是否为索引项的第一条记录的指针，是则令其指向下一条记录，否则删除对应的指针即可
   - 如果采用稀疏索引，如果索引不包含该记录的搜索码，则索引不需要做修改；否则判断该记录是否为其搜索码的唯一一条记录，是则用下一个搜索码值创建索引项替换该索引项，不是则使索引项指向有相同搜索码值的下一条记录

4. B+树结构：B+树的叶结点至多含有指向n-1条记录的指针，最少包含(n-1)/2的上界个指针(不包括尾指针)，搜索码值在叶节点处按顺序排序，叶结点第n个指针指向下一个叶结点；B+树的非叶结点形成叶结点上的多级稀疏索引，非叶结点最多容纳n个指针，至少容纳n/2的上界个指针；根节点至少包含两个指针；搜索码左侧指针指向的子树搜索码小于该搜索码，右侧指针指向的子树搜索码大于等于该搜索码

5. B+树功能

   查询：从根节点开始，找到第一个大于等于目标搜索码的结点搜索码，若该搜索码等于目标搜索码，则置结点指针为右结点，否则为左结点；若找不到这样的搜索码，则置结点指针为当前非叶结点的最右端指针。查找到叶结点时，找到第一个等于目标搜索码的叶结点搜索码，从其左指针开始，按顺序获得所有等于目标搜索码的记录

   插入和删除详见英文书本P643(应该必考，详细看)，注意删除时，若非叶结点搜索码不够，应当删去该非叶节点而将其父结点的一个搜索码与其兄弟节点合并

   更新和查询的开销为O(log(n/2)K)

6. 解决B+树不唯一搜索码的问题：若某个搜索码在记录中出现多次，会导致需要查找很多项的问题，一个简单的解决方法是将该搜索码与其它唯一属性进行复合，使得复合搜索码唯一；还可以使每个搜索码的指针指向一个记录指针的桶，这使得B+树不会重复存储相同的码

7. B+树文件组织：树的叶结点存储对应的记录，叶结点存储的记录数目比非叶结点存储的指针数目少，插入和删除操作与索引类似；B+树文件组织有助于使数据记录聚集化而不用重新组织文件。B+树文件组织需要提升空间的利用，在插入时若某个结点已满，则尝试将它的一些项重新分部到与它相邻的结点中。若相邻点本身已满，则在这两个点和分裂的新结点之间进行分配，使得每个结点大约为2/3满；删除操作也需要考虑上相邻结点

8. 解决因记录移动导致辅助索引重定位的问题：令辅助索引的记录指针改为存储主索引搜索码属性的值，因为主索引的存储顺序始终与文件中记录的存储顺序相同

9. 解决因字符串存在而导致变长搜索码和低扇出的问题：采用前缀压缩技术，非叶结点只存储搜索码的一个足以分开两棵子树的前缀

10. B+树索引的批量加载：先将含有关系索引项的文件根据搜索码进行排序，再将索引项依次插入到索引中，使得每一个叶结点只需要一个IO操作(自底向上的构建方法)

11. B树与B+树的对比：B树在非叶结点中同样也存储记录指针，使得搜索码值在整棵树上只出现一次，因此非叶结点的扇出要小于B+树的非叶结点，整棵树高度增加；由于叶子结点的数量是非叶结点的n倍，即使B树的部分查询不需要找到叶子结点，这个带来的好处是有限的；B树的插入和删除比B+树更加复杂



#### 第十二章

1. 查询执行过程：通过解析和翻译查询语句，获得关系代数表达式后，对表达式添加"如何执行"的注释形成计算原语，生成查询执行计划，选择最低开销的查询计划并将计划交由查询执行引擎完成查询工作

2. 查询代价估计：用磁盘传输块数以及磁盘搜索次数作为代价估量；代价估算不包含将最终结果写回磁盘的代价

3. 选择运算(tr表示传输块的时间，ts表示搜索时间，br表示表的总块数，b表示包含对应记录的块数，n表示满足要求的记录的条数)

   - 线性搜索：系统扫描每一个文件块，对所有的记录都进行测试，查看它们是否满足选择条件；线性搜索的开销为ts + br\*tr(只需要一次磁盘检索，需要遍历所有块)
   - 线性搜索，码属性等值比较：只需要找到一条满足要求的记录即可，搜索开销为ts + br\*tr/2
   - B+树主索引搜索，码属性等值比较：在主索引中进行搜索，等值比较；搜索开销为(h+1)\*(tr+ts) (树的高度为h，每一个树结点都需要一个块传输和块扫描，最后根据叶子结点的信息找到记录对应的块，再需要一次块传输和块扫描)
   - B+树主索引搜索，非码属性等值比较：搜索开销为(h+1)\*ts + (h+b)\*tr
   - 辅助索引，等值比较：若是码属性等值比较，则跟主索引码属性等值比较一致；若是非码属性等值比较，搜索开销为(h+n)\*(tr+ts)(找到对应的叶子结点后，每检索一条记录可能都要一次IO寻块)
   - 主索引，比较：对于<=类的比较，我们直接从文件头开始比较即可，不必去从查找索引。对于>=类的比较，我们在主索引中找到第一条满足的记录，然后顺序查找文件即可，与非码属性等值比较类似
   - 辅助索引，比较(这个个人感觉有歧义)：如果是<=则找到B+树的第一个叶结点，>=则找到第一个满足条件的叶结点，然后按索引顺序查找。与辅助索引的非码属性等值比较类似，但是应当考虑上B+索引的存储方法和叶结点的存储问题
   - 利用一个索引的合取选择：选择某个选择条件和上述一个算法的二元组合，使得代价最小，再在计算得到的元组中测试剩余的选择条件
   - 利用组合索引的合取选择
   - 通过标识符的交或并实现合取或析取选择：对每个条件需要的索引进行扫描，得到记录的指针，求它们的交\并集即可

4. 排序操作

   - 外部排序归并算法：令M表示内存缓冲区中可以用于排序的块数。第一阶段，重复读入M块(除了最后一段)并在内存中完成排序，建立多个排序好的归并段；第二阶段，对归并段进行归并。假设归并段数N小于M，则从每个归并段中读入一个块，并在内存中留一个块作为输出块，用归并排序的方法逐个元组比较，每排好一个块就输出一次。若某个段的块的元组已经全部输出，则再从该段读入一块。如此反复直至所有段都被读完；若第二阶段中，归并的段数N大于等于M，则每次归并M-1个段，得到一个新的段，段数为原来的1/(M-1)的上界，进行多轮后完成排序

   - 外部排序归并算法代价分析：设总块数为br。第一阶段分段需要读入所有块，输出所有块，每个段连续存储，每个段需要一次块检索，因此代价为2\*br\*tr + 2\*upper(br/M)\*ts；第二阶段共需要排序upper(log(M-1)(br/M))轮，每轮同样读入所有的块，输出所有的块，最后一趟不写入磁盘，因此传输块的代价为(2\*upper(log(M-1)(br/M)) - 1)\*br\*tr。每一轮每个块都需要一次块检索，因此检索块的代价为(2\*upper(log(M-1)(br/M)) - 1)\*br\*ts。如果每轮给一个段分配b个块(包括输出段)，则磁盘搜索次数变为

     <img src="C:\Users\pentakill\AppData\Roaming\Typora\typora-user-images\image-20220108161140996.png" alt="image-20220108161140996" style="zoom:50%;" />

5. 连接运算

   - 嵌套循环连接：两个关系中逐个元组进行比较，通过两个for循环来实现；运算代价(最坏)为 nr \* bs + br次块传输以及 nr + br次块检索

   - 块嵌套循环连接：两个关系中分别读入一个块，只有当两个块的元组都比较完毕后，内循环的关系才读入下一个块；运算代价(最坏)为 br \* bs + br次块传输以及2br次块检索

   - 上述两种连接方法可以进一步改进(通常都是需要留一个块给输出)

     <img src="C:\Users\pentakill\AppData\Roaming\Typora\typora-user-images\image-20220108163304680.png" alt="image-20220108163304680" style="zoom:50%;" />

   - 索引嵌套循环连接：若在内存循环的连接属性上有索引，可以用索引替代文件的扫描。对于外层关系r的每一个元组tr，可以利用索引查找s中和tr满足连接条件的元组。运算的代价为 br(tr+ts) + nr \* c，其中c为进行一次索引检索的代价，这里的意思是对于外层关系r，它的每一块都需要一次块传输和一次检索(查找索引时磁头移动)，对于每一个元组都需要进行一次索引检索

   - 归并连接(自然连接和等值连接)：首先依据两个关系的共同属性值对两个关系进行排序，然后用双指针的方法，逐个比较。不计算排序的代价的话，运算代价仅为 br + bs次块传输和检索。如果给每个关系分配b个缓冲块，检索次数缩减为(br+bs)/b。排序的代价参考外部归并排序

   - 散列连接(自然连接和等值连接)：用散列函数h将两个关系的共同属性的值映射到{0,1,2……,Nh}，将两个关系按散列映射值进行划分，并对每一个划分进行连接。对每个划分进行连接时，首先用另一个散列函数对s的划分中的元组进行映射，再用r的划分中的元组映射后与其比较(这个是在内存中做的工作，不用太多考虑)。散列函数h应当能让关系s的每个划分能完整装入内存。若Nh大于内存块数，则需要进行递归划分；如果s某个划分的元组数量过多，则需要进一步进行划分，或者在划分前仔细选择哈希函数

   - 散列连接的代价：

     如果不需要递归划分，每个关系的划分至少需要一次完整的读入和写回。由于可能存在划分未满一个块的情况，因此这些块同样需要写回和读入。每个划分的连接操作需要划分块的一次读入，因此传输代价为3(br+bs) + 4Nh块。假设为输入和输出缓冲区分配了b块，则划分需要2(br/b + bs/b)次磁盘检索。连接阶段需要2Nh次磁盘检索

     如果需要递归划分，分析如下

     <img src="C:\Users\pentakill\AppData\Roaming\Typora\typora-user-images\image-20220108173124142.png" alt="image-20220108173124142" style="zoom:50%;" />



#### 第十三章

1. 查询优化：从许多等价策略中找出最高效的查询执行计划；优化包括关系代数表达式的优化以及查询执行策略的优化

2. 查询优化基于关系的统计信息、中间关系的统计信息估计、算法的开销

2. 等价规则(一些显然的就不写在这里)

   - 一系列投影运算只有最后一个是必须的

     <img src="C:\Users\pentakill\AppData\Roaming\Typora\typora-user-images\image-20220108194510904.png" alt="image-20220108194510904" style="zoom:50%;" />

   - 自然连接运算满足结合律

     <img src="C:\Users\pentakill\AppData\Roaming\Typora\typora-user-images\image-20220108194957136.png" alt="image-20220108194957136" style="zoom:50%;" />

   - 选择运算在下面情况满足分配律

     <img src="C:\Users\pentakill\AppData\Roaming\Typora\typora-user-images\image-20220108195250227.png" alt="image-20220108195250227" style="zoom:50%;" />

   - 投影运算在下面情况满足分配律

     ![image-20220108195736630](C:\Users\pentakill\AppData\Roaming\Typora\typora-user-images\image-20220108195736630.png)

   - 选择运算对并、交、差运算具有分配律

     <img src="C:\Users\pentakill\AppData\Roaming\Typora\typora-user-images\image-20220108195936792.png" alt="image-20220108195936792" style="zoom:50%;" />

   - 对于outer join，如果θ1只与E1属性有关，则

     <img src="C:\Users\pentakill\AppData\Roaming\Typora\typora-user-images\image-20220108201126145.png" alt="image-20220108201126145" style="zoom:50%;" />

   - outer join不保持结合律



#### 第十四章

1. **事务：构成单一逻辑工作单元的操作集合，其操作访问和修改数据库中的数据项**，其ACID特性为

   - 原子性：事务要么不执行，要么执行其所有的内容，作为一个单一的、不可分割的单元出现
   - 隔离性：事务需要能被正常执行而不被其它并发执行的数据库语句干扰。在事务看来，它是当前唯一在执行的操作
   - 持久性：事务的操作结果能够持久地保留在系统中
   - 一致性：事务保持数据库的一致性，满足显式的和隐式的完整性约束

2. 并发多个事务执行的原因：提高吞吐量和资源利用率(IO操作和CPU操作可以并行执行)、减少响应时间

2. 调度是指决定了并发事务的指令的执行时间顺序的指令序列

3. 冲突可串行化：对于两条不同事务上的指令I、J，若它们在相同数据项上操作，且至少有一个是write指令时，这两条指令是冲突的；若调度S的两条不同事务上的连续指令不冲突，则可以调换两条指令的顺序而不影响结果，此时交换前后的调度冲突等价；**如果某个调度与串行调度冲突等价，我们称其是冲突可串行化的**

4. 用优先图判断冲突可串行化：优先图中，存在边Ti->Tj的条件为

   <img src="C:\Users\pentakill\AppData\Roaming\Typora\typora-user-images\image-20220107101117286.png" alt="image-20220107101117286" style="zoom:50%;" />

   如果优先图中不存在环，则调度S是冲突可串行化的

5. 视图等价：满足如下条件的S\`，我们称之与S视图等价

   - 如果S中的事务T1读取了Q的最初值，那么S\`中的T1也需要读取Q的最初值
   - 如果S中事务T2读取了由T1产生的Q值，那么S\`中的T2也需要读取的是T1产生的Q值
   - 如果最终由T1来完成Q的写操作，那么S\`中也需要由T1完成最终的写操作

   与串行调度视图等价的调度称为视图可串行化，某个视图可串行化但不是冲突可串行化的调度存在盲写(不读直接写)

6. 可恢复调度：如果T2读取了T1写的数据项，则T2应当在T1之后提交

   无级联调度：如果T2需要读T1写的数据项，则这个读操作应当在T1提交后进行(避免级联回滚的情况)
   
8. 并发控制的要求：调度为冲突可串行化或视图可串行化，且至少是可恢复调度(最好为无级联调度)

9. 并发控制与串行化测试的关系：并发控制协议满足了调度为冲突可串行化或视图可串行化，且至少是可恢复调度，但在生成后不会再进行串行化测试；串行化测试帮助我们了解并发控制的正确性



#### 第十五章

1. 共享型锁：T1获得共享型锁后只能进行读操作，其它事务也能同时获得共享型锁，通过lock-S指令获得

   排他型锁：T1获得排他型锁后可以进行读写操作，此时其他事务不能获得锁，通过lock-X指令获得

2. 避免饥饿的方法：当事务T申请对数据项Q加M型锁时，若不存在在数据项Q上持有与M型锁冲突的锁的事务，且不存在正在等待的先于T申请锁的事务，则事务T可以获得对应的锁

3. 两阶段封锁协议：事务分为两个阶段提出加锁和解锁的申请(增长阶段、缩减阶段)，一旦事务释放了锁，则它不能再发出加锁请求；两阶段封锁协议保证冲突可串行化；对于锁可升级、降级的机制，升级只能发生在增长阶段，降级只能发生在缩减阶段

   严格两阶段封锁协议：事务持有的排他锁必须在事务提交后才能释放(防止其他事物读取未提交的写结果，形成无级联调度)

   强两阶段封锁协议：事务持有的锁(包括共享锁)必须在事务提交后才能释放

4. 树形协议：(只使用排他锁)对于每个事务T，它首次加锁可以对任何数据项进行；此后，它对任何数据项Q加锁的前提是T持有Q父项上的锁；Q可以对任何持有的数据项进行解锁；数据项Q被T解锁后，T不能再对其加锁。树形协议不产生死锁，确保冲突可串行化，提前了锁的释放，但是可能会出现没必要的加锁，不保证可恢复调度

5. 死锁

   定义：事务集中两个或多个事务因竞争统一资源，互相对其他事务需要的资源加锁而导致的循环等待现象

   死锁预防：

   - 要求事务在发出加锁请求时请求获得所有的锁来防止循环等待；
   - 对所有数据项定义一个次序，要求事务只能按次序规定的顺序封锁数据项
   - 基于抢占回滚的机制：wait-die机制要求当T当前申请的数据项被T1占有时，若T比T1老则允许T等待，否则T不等待直接回滚；wound-wait机制要求若T比T1年轻则T等待，否则令T1回滚释放锁
   - 若申请锁的事务在一定时间内没能申请成功，则事务回滚

   死锁检测与恢复：

   - 死锁检测用有向图可以精确描述，如果T1持有T需要的数据项，则存在从T->T1的有向边，表示T等待T1释放数据项。只有当有向图包含环时，系统中存在死锁
   - 死锁恢复通过选择要回滚的事务和如何回滚完成，分为部分回滚和全部回滚

6. 多粒度可以通过增加意向锁类型实现，应用在数据库的结构树上，对某个结点加S或X锁之前必须先对其所有祖先节点增加意向锁。IS、IX表示事务将对当前结点的子树部分申请S锁或X锁，SIX表示在当前结点加上S锁，并将对子树部分申请X锁。根据这些含义，不难推出相容性矩阵。锁的申请是自根至底，锁的释放是自底至根的



#### 第十六章

1. 失败类型：

   - 事务失败：内部逻辑错误、系统错误(死锁等)
   - 系统崩溃：系统因为掉电或其它原因导致系统崩溃
   - 磁盘错误：磁盘中的内容出现损坏

1. 日志定义：日志是存储在稳定存储器上的，由一系列日志记录组成的文件，记录了数据库上的更新行为信息。日志记录包含的字段为事务标识、数据项标识、旧值、新值

2. 日志中如果出现了commit或abort，则对该事务进行重做redo；如果没有出现这两条记录，则需要进行撤销undo；

3. 检查点：将位于主存的日志记录输出到稳定存储器；将修改的缓冲块输出到磁盘；将日志记录checkpoint L输出到稳定存储器，其中L表示当前活跃的事务列表(未提交的事务)

4. 恢复算法

   事务回滚undo：从后往前扫描日志，发现每一个形如<Ti，Xj，V1，V2>的日志记录，则将V1写入Xj中，并将只读的日志记录<Ti，Xj，V1>写入日志中，并在发现start日志记录后写一个abort日志记录

   系统崩溃后的恢复：

   - 重做阶段：从最后一个检查点开始正向扫描日志来重放所有事务的更新。将要回滚的undo-list设为检查点处的L，重做遇到的所有操作，发现start记录时将对应事务加入undo-list，发现abort或commit记录时将事务从undo-list中去掉
   - 撤销阶段：回滚undo-list中的所有事物，直至undo-list变成空表
