#### 第一章

1. 编译器是一个程序，它能够将用源语言编写的程序翻译成为一个等价的、用目标语言编写的程序；解释器直接利用用户提供的输入执行源程序中指定的操作

2. 编译器产生的机器语言目标程序的执行效率要高于解释器，但解释器的错误诊断比编译器更好，因为它逐个语句地执行源程序，且解释器具有强可移植性

3. 编译器前端：词法分析、语法分析、语义分析、中间代码生成。目的在于产生源程序的中间表示以及将相关信息放入符号表

   编译器后端：代码优化、目标代码生成。目的在于根据中间表示和符号表中的内容，构造出所需要的目标程序
   
4. 高级语言与低级语言的主要不同点：高级语言可以有表达式、高级语言有强可移植性(低级语言往往与机器相关)



#### 第二章

1. 程序的语法描述了该语言的程序的正确形式，语言的语义定义了程序在运行时刻做什么事情

1. 对于语言的定义方法：用表达式描述语言、用文法生成语言、用自动机识别语言

2. 上下无关文法由四个元素组成

   符号表，即终结符号的集合，即构成该语言程序的基本符号的集合

   非终结符号的集合，每个非终结符号代表一个终结符号串的集合

   产生式的集合，产生式由产生式头和产生式体组成，产生式头为非终结符号，产生式体为由终结符号和非终结符号构成的串

   文法开始符号(指定一个非终结符号作为开始符号)

3. 文法定义的语言：可以从开始符号推导得到的终结符号串的集合称为文法定义的语言。一次推导指的是将当前符号串中的非终结符号替换为它的某个产生式体

4. 语法分析的任务：以一个终结符号串作为输入，找到从文法的开始符号推导得到这个终结符号串的方法，构造出对应的语法分析树。ε的语法分析树表达为所有叶结点都为ε的树

5. 结合性质判断：当一个运算分量左右两侧都有运算符时，判断其属于哪个运算符。在产生式中，左结合的运算符往往是左递归的，如E->E+T，右结合的运算符往往是右递归的，如E->T^E(有特殊情况，如消除左递归后无法直接看出运算符的结合性质)

6. 语法制导定义：把每个文法符号与一个属性集合相关联，把每个产生式与一组语义动作相关联，语义动作利用文法符号的属性值进行相应的计算或执行动作。

   语法制导翻译方案：在产生式中嵌入语义动作，显式地规定语义动作的执行顺序，文法符号依旧与一个属性集合相关联。在带有语义动作的语法分析树上，语义动作用虚线表示，按照其在产生式中出现的顺序添加到语法分析树上

7. 注释语法分析树：如果在语法分析树上的各个节点上标注了节点对应的属性值，该语法分析树就称为注释语法分析树

8. 综合属性：如果语法分析树上的某个节点的某个属性是由其节点本身的属性值以及其子节点的属性值确定的，该属性称为综合属性

   继承属性：如果某个属性的值还需要根据结点的父结点和兄弟结点的属性值决定，则该属性为继承属性



#### 第三章

1. 词法分析器任务：读入源程序的输入字符、将它们组成词素，生成并输出一个词法单元序列，每个词法单元对应一个词素；它还可以过滤源程序中的注释和空白，以及定位对应的错误信息

1. 编译模型中，词法分析是前端最花时间的部分，代码优化是整个编译中最花时间的部分

2. 词法分析与语法分析分离的原因

   简化编译器设计，例如将空白字符等在词法分析处进行过滤，简化了语法分析器的处理

   提高编译器效率，可以使用专用于词法分析的技术和输入缓冲来提升词法分析的效率

   提升可移植性，将与输入设备相关的特殊性限制在词法分析中

3. 词法单元、模式和词素

   词法单元由词法单元名和可选的属性值组成，是语法分析器处理的输入符号。标识符的属性值是指向符号表对应条目的指针

   模式描述了词法单元的词素可能具有的形式

   词素是源程序中的字符序列，它与词法单元的模式匹配，被识别为该词法单元的一个实例

4. 词法单元种类：保留字、运算符、标识符、标点符号、常量

5. 双缓冲区技术：采用两个大小为N的缓冲区，每次读取命令读取N个字符到缓冲区中(不足N个时会读入文件结尾eof)。程序维护两个指针，begin指针指向词素的开始处，forward指向当前用来进行判断的字符，当识别出词素时指向词素的结尾。只要词素的长度不超过N，就能够保证能够正确识别出所有的词素。

   改进的一个方法是扩展每个缓冲区，在每个缓冲区末尾都增加eof标识，从而使程序只有在遇到eof时才判断是否到达了缓冲区末尾，而不是每次移动forward都要进行一次判断。

6. 串和语言的定义

   字母表：字母表是一个非空且有限的符号集合

   串：字母表符号的一个有穷序列

   语言：给定字母表上的任意的可数的串的集合(可数不代表有限)，空集和仅包含空串的集合{ε}都是语言

   <img src="C:\Users\pentakill\AppData\Roaming\Typora\typora-user-images\image-20220619164330705.png" alt="image-20220619164330705" style="zoom:50%;" />

8. 词法规则描述方法

   表达式：正则表达式、正则定义

   文法：正则文法、左\右线性文法

   自动机：NFA、DFA

   有限集合一定可以用正则文法描述，即为正则语言。正则语言不能计数，典型为括号匹配

   <img src="C:\Users\pentakill\AppData\Roaming\Typora\typora-user-images\image-20220625162319474.png" alt="image-20220625162319474" style="zoom:50%;" />

7. 词法和语法字母表的区别

   词法分析的字母表是源程序中输入字符的集合

   语法分析的字母表是词法分析识别并生成的词法单元的集合

   词法分析字母表的变化不直接影响语法分析的字母表

7. 正则表达式优先级

   一元运算符\*具有最高的优先级，并且是左结合的

   连接具有次高的优先级，是左结合的

   |优先级最低，是左结合的

   可以用正则表达式定义的语言叫做正则集合

8. 正则文法

   左线性文法：产生式形如A->Ba|a

   右线性文法：产生式形如A->aB|a

   A->ε存在当且仅当A为开始符号且A不出现在任何产生式右端

   产生式不能出现多个非终结符的情况

   与正则定义不同的是上面的产生式可以使用下面的符号，且不能使用正则表达式的运算符

   <img src="C:\Users\pentakill\AppData\Roaming\Typora\typora-user-images\image-20220625164801902.png" alt="image-20220625164801902" style="zoom:50%;" />

8. 有限自动机

   NFA：一个符号可以标记离开同一状态的多条边，空串ε也可以作为标号

   DFA：每个符号只能标记离开同一状态的一条边，没有ε转换

   NFA和DFA能够识别的语言集合是相同的，为正则语言

   NFA的组成部分：有限的状态集合S、符号表、开始状态、终止状态集合以及转换函数(指示一个状态对每个符号的后继状态集合，符号包含了ε)

   注意NFA和DFA的转换图中，**开始状态前要添加箭头，终止状态要用双圆表示**。NFA的转换表形如(DFA的转换表每个项至多有一个状态，且不需要考虑ε)

   <img src="C:\Users\pentakill\AppData\Roaming\Typora\typora-user-images\image-20220619174607548.png" alt="image-20220619174607548" style="zoom:50%;" />

   一个字符串属于该NFA定义的语言当且仅当转换图中存在一条从开始状态到某个终止状态的路径，使该路径上的标号组成了该字符串。NFA定义的语言为从开始状态到某个终止状态的所有路径上的标号串的集合

9. NFA转换为正则文法

   <img src="C:\Users\pentakill\AppData\Roaming\Typora\typora-user-images\image-20220619225755900.png" alt="image-20220619225755900" style="zoom:50%;" />

10. 左、右线性文法转为NFA

    <img src="C:\Users\pentakill\AppData\Roaming\Typora\typora-user-images\image-20220619225957153.png" alt="image-20220619225957153" style="zoom:50%;" />

11. NFA到DFA转换：子集构造法(复习时自行回忆，通过例子来复习)

    ε闭包：从NFA的状态集合s开始只通过ε转换到达的NFA状态集合，一个状态集合只对应一个ε闭包

    获得的DFA的终止状态指至少包含NFA的一个终止状态的状态集合

12. 正则表达式构造NFA：Thompson算法

    <img src="C:\Users\pentakill\AppData\Roaming\Typora\typora-user-images\image-20220619200551779.png" alt="image-20220619200551779" style="zoom:50%;" />

    <img src="C:\Users\pentakill\AppData\Roaming\Typora\typora-user-images\image-20220619200601394.png" alt="image-20220619200601394" style="zoom:50%;" />

    得到的NFA的状态数至多为运算符和运算量的两倍；有且只有一个开始状态和一个接收状态；除终止状态外每个状态要么有一条标号为字符表中的符号的出边，要么有两条标号为ε的出边

13. 自动机同构：如果一个自动机只需要改变状态的名字就可以转换成为另一个自动机，我们称这两个自动机是同构的

14. 最小化DFA状态数(任何正则语言都有唯一的状态数目最少的DFA)

    首先将终结状态和非终结状态划分为两个不同的分划。之后，对于任意两个不同的DFA状态，如果它们经过任何一个标号到达的分划都是一致的，那么这两个状态属于同一分划。根据这个原理不断找到不同的分划，直到分划不变为止。此时每个分划都属于新的DFA的一个状态。

    <img src="C:\Users\pentakill\AppData\Roaming\Typora\typora-user-images\image-20220619204709379.png" alt="image-20220619204709379" style="zoom:50%;" />



#### 第四章

1. 语法分析任务：从词法分析器中获得一个由词法单元组成的序列，验证这个序列可以从源语言的文法生成，找到从开始符号推导得到该序列的方法，进而构造出对应的语法分析树。语法分析逻辑上输出语法分析树，实际上输出的是构成分析树的一个个产生式，产生式序列与语法分析树的构造顺序有关

2. 语法分析器中的错误处理目标：精确报告出错误、能够从错误中恢复、尽量少地增加处理正确程序时的开销

3. CFG的组成部分：终结符号(词法单元名)集合、非终结符号(表示终结符号串的集合)集合、开始符号、产生式(非终结符号推导出的串应具有的形式)集合

4. 推导的符号为=>，表示一次推导(将某个非终结符替换为它的某个产生式体)

5. 上下文无关文法基本概念

   句型：从开始符号经过0次或多次推导得到的可能由终结符号和非终结符号组成的串(也可能为空串)

   句子：只包含终结符号或为空串的句型

   短语：如果S=>\*αAω=>αβω，则称紧跟在α后的β是αβω关于父结点A的短语。一个句型的语法树中任一子树叶结点所组成的符号串都是该句型的短语。描述短语从位置、子串以及父结点来表示，即紧跟在α后面的β是关于根节点A的短语

   文法生成的语言：文法的所有句子的集合。若两个文法生成相同的语言，称这两个文法是等价的

   最左推导：每次推导都选择句型的最左非终结符号进行替换。由最左推导得到的句型称为最左句型。最左推导符号为<img src="C:\Users\pentakill\AppData\Roaming\Typora\typora-user-images\image-20220619223809667.png" alt="image-20220619223809667" style="zoom:25%;" />

   最右推导：每次都选择最右非终结符号进行替换，也称规范推导。由最右推导得到的句型称为最右句型

   语法分析树：推导的图形表示形式，过滤了推导过程中选择非终结符号的顺序。语法分析树可以是一个句子的语法分析树，也可以是一个句型的语法分析树，其代表的句型由它的叶子节点标号所决定。每一棵语法分析树都和唯一的最左推导和唯一的最右推导相关联

   文法二义性：对同一个句子有多个最左推导或最右推导的方法，或者说该句子有多个语法分析树。如果ε是文法生成的句子，那么两种推导出ε的方法也算二义性

6. 每个正则文法都属于上下文无关文法，即上下文无关文法包含了正则文法。正则文法小于上下文无关文法的原因是正则文法不能计数，即对于括号匹配的问题，在碰到右括号时无法记录左括号的数目。上下文无关文法无法解决先声明后使用和形参与实参数量相同的问题

7. 不使用文法设计词法语法的原因：

   将语法结构分为词法和语法两部分可以简化编译器结构，将前端分解为大小适中的组件，因此词法和语法模块分别进行设计
   
   文法的表达性强，而词法规则较为简单，不需要使用这种表达性强的表达方法来描述词法规则
   
   利用正则表达式产生的自动机的处理效率要高于文法分析器处理效率
   
   正则表达式的表示更加简洁且易于理解
   
8. 消除二义性例子

   <img src="C:\Users\pentakill\AppData\Roaming\Typora\typora-user-images\image-20220620150008505.png" alt="image-20220620150008505" style="zoom:50%;" />

9. ε-free文法：文法的所有非终结符号都没有ε，或只有开始符号能够有ε产生式，且开始符号不在任何的产生式体中。**在消除ε产生式时，如果存在S->ε且S出现在某个产生式中，则需要增广文法开始符号为S\`->S|ε**

9. 左递归消除

   直接消除方法：将非左递归的产生式作为开头，修改为右递归的形式(**记得新增的非终结符的产生式要加上ε**)。对于形如A->Aα|β的产生式，修改为A->βA\`，A\`->αA\`|ε

   ![image-20220620150803942](C:\Users\pentakill\AppData\Roaming\Typora\typora-user-images\image-20220620150803942.png)

   系统消除方法：首先消除ε产生式，即若存在A->ε产生式，则对于所有包含A的产生式的非终结符号，增加去除A的产生式(枚举所有A->ε的情况)，并将A->ε移除。接下来利用算法

   <img src="C:\Users\pentakill\AppData\Roaming\Typora\typora-user-images\image-20220620151558364.png" alt="image-20220620151558364" style="zoom:50%;" />

10. 提取左公因子

    对于A->αβ1|αβ2两个A的产生式，具有左公因子，则修改为A->αA\`，A\`->β1|β2

11. 递归下降预测分析器的设计流程

    解决文法的二义性

    系统消除左递归

    合并左公因子

    根据文法构建出转换图

    根据转换图设计对应的过程，得到递归下降预测分析器

11. FIRST和FOLLOW

    FIRST(α)定义为可以从句型α推导得到的终结符号串的首符号的集合；如果α可以推导出空串，那么ε也在FIRST(α)中。FIRST集合中不会包含$。计算FIRST的规则为

    ![image-20220620201128810](C:\Users\pentakill\AppData\Roaming\Typora\typora-user-images\image-20220620201128810.png)

    FOLLOW(A)定义为可以在某些句型中紧跟非终结符号A的符号的集合；如果A是某些句型的最右符号，那么$也在FOLLOW(A)中。FOLLOW集合中不会包含ε**(切记开始符号的follow包含$)**。计算FOLLOW的规则为

    ![image-20220620201209789](C:\Users\pentakill\AppData\Roaming\Typora\typora-user-images\image-20220620201209789.png)

    文法是LL(1)的当且仅当对于一个非终结符号A，它的所有产生式的FIRST集合不相交，且如果存在某个产生式的FIRST包含ε，那么A的FOLLOW集也不能与任何产生式的FIRST集相交

12. 预测分析器转换图：为每一个非终结符都创建一个转换图，边的标号既可以是终结符号，也可以是非终结符号。每个转换图创建一个初始状态和一个结束状态，对于每个产生式A->BCDEF，创建一条从开始状态到结束状态的路径，路径标号分别为B、C、D、E、F(ε同理)。开始状态不用加上箭头，结束状态用双圆表示

    <img src="C:\Users\pentakill\AppData\Roaming\Typora\typora-user-images\image-20220620203608288.png" alt="image-20220620203608288" style="zoom:50%;" />

    预测分析表：行为所有非终结符号，**列为所有终结符号以及$**。对于产生式A->α，当符号a位于FIRST(α)时，将A->α填入表格M[A,a]中。若FIRST(α)包含ε，则将A->α填入M[A,b]中，其中b表示FOLLOW(A)的所有符号。填写步骤为

    <img src="C:\Users\pentakill\AppData\Roaming\Typora\typora-user-images\image-20220620203449456.png" alt="image-20220620203449456" style="zoom:50%;" />

    <img src="C:\Users\pentakill\AppData\Roaming\Typora\typora-user-images\image-20220620203418320.png" alt="image-20220620203418320" style="zoom:50%;" />

13. 自顶向下语法分析器

    递归下降预测分析器：为每个非终结符号建立对应的过程，根据产生式插入match操作和其他过程

    LL(1)分析器：显式维护一个栈和转换表，根据转换表的内容决定操作(table-driven)，还需要一个general的控制程序controller。栈中开始为$S，输入缓存中为tokens+$，匹配结束后两边都只剩下$
    
13. 预测分析中的错误恢复

    可能出现的情况：Mismatch of terminals、 [top, lookahead] = empty、Empty stack with input remaining

    恐慌模式恢复：通过不断地将输入中的符号移除，直到碰到了某些同步词法单元集合内的某个词法单元，然后将栈顶的非终结符弹出。对于非终结符号A，它的同步集合可以包括它的FOLLOW和FIRST集合。一个常用的方法是在遇到错误条目时，如果当前字符属于FOLLOW(A)，那么将A移出栈顶，否则将当前的lookahead移除
    
    短语层次恢复：在预测分析表中的空白条目中填写指向错误处理例程的指针，从而在发生预期的错误时，能够进行相应的恢复



#### 自底向上分析

1. 归约：每一步归约将句型中的某个与产生式体匹配的子串替换为该产生式头部的非终结符号；一次归约是一次推导的反向操作

   句柄：当前最右句型的最后一次最右推导采用的产生式，在语法分析树中表现为最左直接短语(最左侧的两层子树)。句柄通过其对应的产生式以及位置进行描述，即对于S=>(rm\*)αAω=>(rm)αβω，紧跟α的产生式A->β是αβω的句柄。句柄右侧一定只包含终结符号。句柄不一定是唯一的，但无二义性的文法中句柄一定是唯一的。只有最右句型才会有句柄

   素短语：是指一个短语至少包含一个终结符，并且除它自身之外不再包含其他素短语(即最小素短语)

2. OPP：维护算符优先关系表，显式维护算符栈，归约最左素短语。文法要求不能有ε产生式，且产生式中非终结符不能相邻

2. LR语法分析：表格驱动的自底向上的分析，在最右句型的句柄出现在符号栈栈顶时能够马上进行归约

3. LR分析技术特点：应用范围广、语法分析处理高效、快速检测出错误、应用范围涵盖了LL类、分析表大导致难以手工构造

4. LR(0)分析的项item：LR(0)分析的项是文法中的一个产生式加上位于产生式体中的一个点，如A->X·YZ。项指明了在当前状态下，我们已经看到了产生式的哪些部分，并期望在接下来的分析中获得哪些部分(A->ε生成项A->·)

   LR(1)分析的项：在LR(0)的项的基础上，增加上lookahead集合，表示遇到哪些符号时可以进行归约。如对于A->XY·,a/b，当遇到a或b时可以将XY归约成A

   LR分析的状态：LR自动机的一个状态由一个项集构成。该项集包含了核心项和闭包项，核心项唯一地确定了一个项集，闭包项由核心项递归推导得到。核心项为初始项S\`->S以及其他所有点不在最左端的项，闭包项为除S\`->S外的所有点在最左端的项。

5. LR分析增广文法：对任意LR分析技术，**我们采用增广文法的方式，增加一个S\`->S的产生式**，使得文法的开始符号不会出现在任何产生式的右侧，且开始符号只有唯一的产生式，从而得到唯一的接受状态

6. LR(0)语法分析

   LR(0)闭包计算：对于每一个形如A->α·Bβ的项(开始状态的核心项为S\`->S)，若B->γ是一个产生式且不在当前闭包中，则将B->γ加入闭包中。不断应用这个规则直到闭包不变化为止

   LR(0)自动机：开始状态要添加箭头，所有状态都使用双边框标识(因为自动机识别的是所有能够出现在符号栈中的串，即所有的活前缀，每个状态都能是终结状态)；每个状态中为一个项集，且需要加上标号表示这是第几个状态，状态转移包含了终结符和非终结符

   LR(0)分析需要的结构：维护符号栈和状态栈(符号栈是可选的，可以从状态推断得到)，使用输入缓存保存输入的词法单元序列，LR状态转换表。状态栈维护了过去的分析过程，解决了文法无记忆性的问题

   LR(0)分析表：LR(0)分析表行为所有的状态，列分为ACTION和GOTO两个部分。ACTION为所有的**终结符号以及$**，GOTO为所有的**终结符号+非终结符号**(终结符号部分通常与ACTION合并)。ACTION共有四个动作：移入j表示将对应的lookahead移入栈中，并将状态j压入栈；归约i表示将栈顶的句柄规约为产生式i的产生式头，并根据产生式体的字符数量弹出对应数量的状态(归约和移入中的数字代表的意义不同，归约表示产生式序号，移入表示状态序号)；接收表示语法分析完毕；报错表示语法分析器发现了一个语法错误。GOTO中记录的是前往的状态号，即GOTO[i，A] = j表示归约获得A后，若栈顶为状态i，则将状态j入栈

   ![image-20220620225818201](C:\Users\pentakill\AppData\Roaming\Typora\typora-user-images\image-20220620225818201.png)

   所有的LR分析表的驱动程序都是相同的，只是分析表因分析方法的变化而不同。

7. SLR(1)语法分析

   LR(0)语法分析的缺陷在于：若当前状态存在一个可规约的核心项，形如A->αβ·，则对于任意一个lookahead终结符号，它的语义动作都设定为归约该产生式。这个归约条件过于宽泛，会出现很多的table conflict

   SLR(1)语法分析利用FOLLOW集，试图限制归约条件，减少冲突。对于一个可归约项A->α·，只有当lookahead属于FOLLOW(A)时，才能使用此归约项进行归约。这样的限制使语法分析更加精准，减少了冲突

   ![image-20220621103935219](C:\Users\pentakill\AppData\Roaming\Typora\typora-user-images\image-20220621103935219.png)

8. 活前缀：所有最右句型中不超过其句柄的前缀子串的集合。活前缀是一个最右句型的前缀，且它不会超过该最右句型的句柄。所有可能出现在LR分析的符号栈的文法符号串即为活前缀的集合(LR(0)自动机从开始状态到任意状态的路径的标号形成一个可行前缀)。活前缀的右端增加一些终结符号即可获得一个最右句型

   LR(0)有效项：若当前状态存在项A->β·γ，它是活前缀αβ的有效项当且仅当存在某个最右推导S\`=>\*αAω=>αβγω

9. LR(1)语法分析

   采用FOLLOW集合依然过于宽泛，因为事实上对于某些活前缀βα，即使a在FOLLOW(A)中(假设产生式为A->α)，它不可能紧跟在前缀为βA的任何最右句型的βA之后

   LR(1)语法分析的项期望能够维护一个lookahead集合，精确地指明在当前活前缀下，哪些输入符号可以跟在句柄α后面。项的一般形式修改为[A->α·β，a]，其中a是终结符号或者$。当出现形如[A->α·，a]的项时，只有lookahead为a，才能视A->α为句柄进行归约

   LR(1)有效项：若当前状态存在项[A->β·γ，a]，它是活前缀αβ的有效项当且仅当存在某个最右推导S\`=>\*αAω=>αβγω，且a为ω的第一个符号或者ω为ε且a为$

   LR(1)项集计算：与LR(0)不同的在于lookahead的计算，注意FIRST(βa)的计算要算准算全

   <img src="C:\Users\pentakill\AppData\Roaming\Typora\typora-user-images\image-20220621114047337.png" alt="image-20220621114047337" style="zoom:50%;" />

   每个SLR(1)文法都是LR(1)文法，但是LR(1)语法分析器的状态要远大于SLR(1)的状态

10. LALR语法分析

    LALR语法分析的状态数与SLR状态数相同

    LALR(1)的DFA是在LR(1)的DFA基础上，将所有core(即除去lookahead的部分)相同的状态进行合并，其中lookahead集合取并集

    LALR(1)状态合并后不会产生新的移入-归约冲突，但可能产生新的归约-归约冲突

11. 利用二义性文法进行LR分析的优势：文法的归约更短、更自然，且文法的表达更加简洁且易于理解；可以通过增加消除二义性的规则消除二义性，且不会增加LR分析的状态数目；二义性文法的语法分析器不会将时间浪费在单产生式的归约上(单产生式指产生式体中只包含一个非终结符号的产生式)

12. LR语法分析中的错误恢复

    恐慌模式恢复策略：不断弹出状态栈，直到栈顶的状态i能够通过某个非终结符号A转移到另一个状态，此时我们假设已经从输入中获得了符号A。我们将GOTO(i,A)入栈，并不断跳过输入，直到当前lookahead位于FOLLOW(A)中。

    短语层次恢复：检查LR分析表中的每个报错条目，添加指向对应的错误处理例程的指针。每个错误例程为不同的修改方法，如忽略一个输入、插入一个输入等



#### 第五章

1. 语法制导定义SDD：上下文无关文法与属性和规则的结合，属性与文法符号相关联，语义规则与产生式相关联

2. 综合属性：分析树结点N上的非终结符号A的综合属性是由N上的产生式关联的语义规则来定义的。它的取值由A的其他属性(可以是继承属性)以及N的子节点的属性确定。综合属性不能由父结点和兄弟结点定义

   继承属性：分析树结点N上的非终结符号B的综合属性由N的父结点上的产生式关联的语义规则来定义的。它的取值由N的父结点、N本身、N的兄弟结点的属性确定。继承属性不能由子结点的属性来定义

   终结符号可以有综合属性，但不能有继承属性，因为它的属性值是由词法分析器提供的

3. S-attribute SDD：只包含综合属性的SDD。该SDD的每个非终结符号的属性值都由其自身产生式的语义规则进行定义。S-attribute SDD的属性值可以直接通过对树的后序遍历计算，因此可以与一个LR语法分析器一起自然地实现

   L-attribute SDD：每个属性要么是综合属性，要么是只能依赖于父结点、左边的兄弟结点和自身属性的继承属性。L-attribute SDD的属性值可以通过深度优先搜索进行计算

4. 树上结点显示了各个属性的值的语法分析树称为注释语法分析树

5. 属性依赖图

   对于每个语法分析树的结点，与其关联的每个属性在依赖图中都有一个结点(side effects也需要有一个结点)

   若A.b的值依赖于X.c的值，那么存在一条从X.c到A.b的边

   属性求值的先后顺序通过在依赖图上进行拓扑排序获得，对任何非循环定义的SDD都可以完整地执行完所有动作

6. 语法制导翻译模式SDT：在产生式体中嵌入合适的语义动作，显式地规定语义动作的执行次序。**嵌入的语义动作用{}括起来，每个语义动作用分号;隔开。语法树中的语义动作用虚线表示**

   SDT用到的属性需要在语法分析过程中新增加一个栈进行记录，且栈中只记录综合属性(还包括终结符号的值)，继承属性需要用其他方法获得

   S-attribute SDD的SDT构造：将每个语义动作都放在产生式的最后，并在将产生式体归约为产生式头时执行这个动作。这种方案称为后缀翻译方案，可以在LR语法分析过程中实现。

   L-attribute SDD的SDT构造：将计算非终结符号A的继承属性的语义动作插入到产生式体中紧靠A的前面，将计算产生式头的综合属性的语义动作放置在产生式体的最右端。

   SDT中消除左递归：如果当前SDT的动作只需考虑其执行顺序，例如动作只是完成一些打印操作，那么将SDT的动作视为文法符号直接进行左递归的消除即可；如果SDT的动作对综合属性进行了计算，则对于形如A->AB | C的产生式，将C的综合属性作为继承属性传递给新增的非终结符号A\`，并将结果从最后一个变为ε的A\`通过综合属性传递到最开始的A。借用书本的例子为

   <img src="C:\Users\pentakill\AppData\Roaming\Typora\typora-user-images\image-20220621210557839.png" alt="image-20220621210557839" style="zoom:50%;" />变为<img src="C:\Users\pentakill\AppData\Roaming\Typora\typora-user-images\image-20220621210606761.png" alt="image-20220621210606761" style="zoom:50%;" />

7. 在语法分析中实现L属性的SDD

   构建语法分析树的方案：忽略所有语法动作，通过语法分析构造出对应的语法分析树；对于语法分析树的每个内部节点，将它使用的产生式中的语义动作作为子结点加入树的对应位置；对该带动作的语法分析树进行前序遍历，得到正确结果。

   使用递归下降分析器的方案：为每个非终结符号A创建一个函数A，函数A的参数是非终结符号A的继承属性，返回值是A的综合属性。在函数A中的匹配动作和过程调用之间插入对应的语义动作，插入位置与SDT中的语义动作位置相同。函数体内用局部变量保存必要的属性值，包括各种产生式体的继承属性和综合属性

   自底向上分析的方案：将每个内嵌的语义动作替换成标记M，并新增产生式M->ε。M->ε增加一个修改后的语义动作，该语义动作将原来需要使用的继承属性进行计算，并转换为M的综合属性，记录在符号栈上。计算使用到的继承属性可以通过合理安排其在栈中的位置获得(栈中保存了非终结符的综合属性以及终结符号)。需要注意的是当前栈的top应当指向的是当前识别完毕的非终结符号



#### 第六章

1. 编译器前端分析源语言相关的细节，后端处理目标机器相关的细节，通过恰当的中间表示可以使不同的前后端有多种组合，有高可扩展性和可优化性。高层的中间表示与源语言的结构相关，低层的中间表示适用于机器相关的处理任务

2. DAG有向无环图：指出了抽象语法树的公共子表达式，对于公共子表达式只创建一个结点，而抽象语法树会为每一个公共子表达式创建一个新的结点

3. 三地址代码

   需要复制指令的原因：为了形式化地生成中间表示，每个子表达式结果都用一个临时变量记录，只有当赋值时才将临时变量值传递给变量

   四元式表示：分为四个字段op、arg1、arg2、result。单目运算符和赋值运算不使用arg2；param运算不使用arg2和result；跳转指令将目标标号放入result

   三元式表示：去除result字段，并用运算的位置表示运算结果，带有括号的数字表示指向相应三元式结构的指针。三元式空间较小，但是难以处理指令重排的问题

   间接三元式：三元式中位置指针不变，在使用时重排指针即可

   <img src="C:\Users\pentakill\AppData\Roaming\Typora\typora-user-images\image-20220622103434261.png" alt="image-20220622103434261" style="zoom:50%;" />

   

4. 类型和声明

   类型等价：两个表达式是相同的基本类型，或是将相同的类型构造算子应用在类型等价的类型表达式构造得到

   类型声明：在执行过程中记录类型的基础类型和类型宽度，并在声明完成时填写对应的符号表，并修改当前的offset；记录的处理需要保存环境后新增一个符号表。符号表最终的offset即为记录类型的宽度；过程的声明也需要新增符号表，但是它的宽度不需要添加到当前的offset中，因为过程调用需要加入一个新的栈，与主程序不是同一个栈空间。过程调用的符号表需要保存其上一级符号表的位置

   具体应用可以再看看PPT

5. 表达式处理

   对于形如E -> id的产生式，将E的地址设置为id在符号表中记录的地址

   对于形如E -> E1 + E2的产生式，将新建一个临时变量E，并将其代码设置为E1 || E2 || gen(E.addr,'=',E1.addr,'+',E2.addr)

   对于形如E -> (E1)的产生式，直接令E的地址和代码与E1相同

   也可以采用增量形式，即只使用gen指令，不需要用E.code记录代码情况，但需要为E生成临时变量以计算结果。**注意对于每一个算术表达式都需要生成一个新的临时变量**

6. 数组元素寻址

   两种不同的模式

   addr = base + i1\*w1 + i2\*w2 + …… + in\*wn

   <img src="C:\Users\pentakill\AppData\Roaming\Typora\typora-user-images\image-20220622114853140.png" alt="image-20220622114853140" style="zoom:50%;" />

​		offset = base – ((...((low1\*n2 + low2)\*n3 + low3 )...)\*nk + lowk)\*w

​		PPT 30

7. 类型检查

   健全的类型系统(源语言的类型规则)可以使得语言在静态过程就能完成类型检查，保证接受的程序在运行时刻不会发生类型错误。这种语言是强类型的

   类型综合：根据子表达式的类型构造出表达式的类型

   <img src="C:\Users\pentakill\AppData\Roaming\Typora\typora-user-images\image-20220622161701384.png" alt="image-20220622161701384" style="zoom:50%;" />

   类型推导：根据语言结构的使用方式推导出结构的类型

   <img src="C:\Users\pentakill\AppData\Roaming\Typora\typora-user-images\image-20220622161728553.png" alt="image-20220622161728553" style="zoom:50%;" />

   表达式类型转换：对于形如E->E1+E2的表达式，先计算出E1和E2之间类型宽度最大的表达式，然后利用转换函数将较小的一方扩展，从而进行计算

   <img src="C:\Users\pentakill\AppData\Roaming\Typora\typora-user-images\image-20220622163049018.png" alt="image-20220622163049018" style="zoom:50%;" />

   <img src="C:\Users\pentakill\AppData\Roaming\Typora\typora-user-images\image-20220622163209279.png" alt="image-20220622163209279" style="zoom:50%;" />

8. 控制流

   if-else、while控制流SDD

   <img src="C:\Users\pentakill\AppData\Roaming\Typora\typora-user-images\image-20220622170100348.png" alt="image-20220622170100348" style="zoom:50%;" />

   布尔表达式控制流SDD

   <img src="C:\Users\pentakill\AppData\Roaming\Typora\typora-user-images\image-20220622171559434.png" alt="image-20220622171559434" style="zoom:50%;" />

9. 回填技术：一趟完成代码生成

   将非终结符号B的综合属性true和false修改为truelist和falselist，列表里面包含了标号未填写的GOTO指令。每一个原来应该用标号的位置用一个非终结符号替代

   对应布尔表达式的翻译方案为

   <img src="C:\Users\pentakill\AppData\Roaming\Typora\typora-user-images\image-20220622215432585.png" alt="image-20220622215432585" style="zoom:50%;" />

   控制流的翻译方案为

   <img src="C:\Users\pentakill\AppData\Roaming\Typora\typora-user-images\image-20220622224101205.png" alt="image-20220622224101205" style="zoom:50%;" />



#### 第七章

1. 活动树：反映了过程调用的顺序的父子关系。对树的前序遍历代表了过程调用的序列，对树的后序遍历代表了返回序列

   <img src="C:\Users\pentakill\AppData\Roaming\Typora\typora-user-images\image-20220623105714125.png" alt="image-20220623105714125" style="zoom:50%;" />

   活动记录：过程在运行时刻栈中的数据，包含的内容有实参(函数的传入参数)、返回值、控制链(调用该过程的过程)、访问链(定义该过程的过程)、机器状态、局部数据、临时变量；调用者管理被调用者局部数据之前的记录，被调用者管理局部数据和临时变量，寄存器sp指向的是局部数据开始部分。

2. 存储管理的期望：减少存储碎片提升空间效率(最重要)，利用局部性提升程序效率，降低分配和回收的时间开销

3. 程序垃圾：不能被引用的数据，即不存在从root到该数据的引用链

   数据可达性：不需要对任何指针解引用就可以直接访问的数据称为根集。若某个对象的引用被保存在可达对象的字段或数组元素中，那么这个对象也是可达的。一旦某个对象变得不可达，它就不可能再次可达

4. 垃圾回收的度量标准：总体执行时间，空间利用情况(减少碎片)，停顿时间，有良好的局部性从而提升程序效率

5. 垃圾回收策略

   引用计数垃圾回收：为每个对象维护其引用的次数，当对象引用次数为0时被确认为垃圾，准备回收。当某个对象引用计数为0时，它引用的对象的引用次数应减1。引用计数不能回收不可达的循环数据结构(对象间具有循环引用)，且开销较大。
   
   基本标记-清扫回收：从根集开始用深度优先搜索，遍历所有从根集开始有一条访问链到达该对象的可达对象，并清除所有的不可达对象。开销与存储块数目成正比
   
   优化标记-清扫回收：通过维护一个对象列表，并在扫描过程中将可达对象移到可达列表中，从而不需要再重新遍历一次整个对象列表就可以获得需要移除的对象列表。开销与可达对象数目成正比
   
   标记并压缩垃圾回收：从根集开始标记所有可达对象，计算可达对象的新存储位置，将可达对象拷贝到堆的开始部分。结果使得空闲块是连续的空间，有良好的局部性。开销与可达对象总大小以及存储块数量成正比。
   
   拷贝回收器：将存储空间分为两个半空间，每次内存只使用其中一个半空间。进行回收时，将被使用的半空间的可达对象按序移动到未被使用的半空间中，拷贝完毕后开始使用这个未被使用的半空间。开销与可达对象总大小成正比。



#### 第八章

1. 代码生成：以编译器前端生成的中间表示和符号表的相关信息作为输入，输出语义等价的目标代码

   代码生成主要任务：指令选择(在多条语义等价的目标代码中选择最恰当的指令)、寄存器分配和指派(选择给哪些变量分配寄存器和确定变量放入哪个寄存器)、指令排序(对指令进行合理排序使其适合流水线式工作等)

2. 寻址模式和指令开销

   如果内存位置是一个常量#1，cost为1

   如果内存位置是一个寄存器，cost为0

   如果内存位置是一个变量名x，cost为1

   如果内存位置是一个间接寻址\*x，间接寻址不增加额外的cost

   如果内存位置是形如a(r)或100(r)的地址，cost为1

   指令的开销计算为内存位置开销之和+1

3. 过程调用的返回地址存储(返回地址存储在活动记录局部变量部分开始处)

   静态分配活动记录(每个过程的活动记录静态分配到某个位置上)

   <img src="C:\Users\pentakill\AppData\Roaming\Typora\typora-user-images\image-20220623223547756.png" alt="image-20220623223547756" style="zoom:50%;" />

   栈分配活动记录(每个过程活动记录被动态分配在栈上)

   用load指令将SP指针设置为栈的起始位置

   调用时增加SP指针的值，并将返回地址保存在SP对应的地址中，然后跳转

   <img src="C:\Users\pentakill\AppData\Roaming\Typora\typora-user-images\image-20220623225608668.png" alt="image-20220623225608668" style="zoom:50%;" />

   最后跳转回caller(BR \*0(SP))，由caller处的代码减少SP的值

4. 基本块和流图

   基本块特点：控制流只能从基本块第一条指令进入，且在最后一条指令离开基本块之前不会停机或跳转

   基本块分割：第一条指令为一个基本块的首指令；任意一个跳转指令的目标指令是一个首指令；紧跟跳转指令后的第一条指令是一个首指令

   liveness和next-use计算(只在基本块中计算)：从基本块B的最后一条语句开始，反向扫描到B的开始处。对于每个语句i：x=y+z，将x设置为不活跃和无后续使用，将y、z设置为活跃，且下次使用设置为i。初始化时临时变量设置为不活跃，外部变量设置为活跃。使用的方法为

   <img src="C:\Users\pentakill\AppData\Roaming\Typora\typora-user-images\image-20220624105045989.png" alt="image-20220624105045989" style="zoom:50%;" />

   流图：从一个基本块B到另一个基本块C有一条边当且仅当基本块C的第一条指令有可能紧跟基本块B的最后一条指令执行(存在跳转指令或是直接穿越)。流图中跳转指令从跳转序号替换为跳转基本块，原因是避免进行基本块代码优化时修改指令导致要修改跳转目标。流图通常要加上entry和exit结点

5. 基本块优化(基本块->DAG->基本块)：

   ![image-20220624110916711](C:\Users\pentakill\AppData\Roaming\Typora\typora-user-images\image-20220624110916711.png)

   消除局部公共子表达式：重复计算一个已经计算得到的值的指令，在新结点加入DAG时检查是否存在运算符、子结点相同的结点

   消除死代码：左值不会被使用的指令，从DAG上删除没有附加活跃变量的根结点

   重新排序指令

   利用代数规则简化计算过程，如乘法变加法、代数恒等式、常量合并等

   数组引用的表示：对于数组赋值操作a[j] = y，它会杀死所有之前的数组取数操作x = a[i]，使这些取数指令不再能成为公共子表达式。两种操作的结点表示为

   <img src="C:\Users\pentakill\AppData\Roaming\Typora\typora-user-images\image-20220624112557215.png" alt="image-20220624112557215" style="zoom:50%;" />

6. 简单的代码生成

   寄存器描述符：每个寄存器都有一个描述符，跟踪有哪些变量当前的值被存在该寄存器内

   地址描述符：每个变量有一个地址描述符，跟踪该变量的值被存放在哪些位置，包括了寄存器、内存地址等

   getReg函数：传入一条指令，获得为各个变量选择的寄存器。具体的选择规则为

   <img src="C:\Users\pentakill\AppData\Roaming\Typora\typora-user-images\image-20220624123358053.png" alt="image-20220624123358053" style="zoom:50%;" />

   基本算法：

   <img src="C:\Users\pentakill\AppData\Roaming\Typora\typora-user-images\image-20220624122237602.png" alt="image-20220624122237602" style="zoom:50%;" />

   复制语句x=y只需要将x加入存放y的寄存器Ry的寄存器描述符即可，如果y不在Ry则需要先进行LD操作。如果变量x在基本块出口处活跃则需要生成ST x，R指令将x存入内存(新的基本块会忽略原来的所有寄存器内容)，其他在寄存器中的变量可以直接抛弃

   算法描述符管理：

   <img src="C:\Users\pentakill\AppData\Roaming\Typora\typora-user-images\image-20220624122532696.png" alt="image-20220624122532696" style="zoom:50%;" />



#### 第九章

1. 优化模式：

   总体层级上，分为源代码优化(人工的)、中间表示优化(机器无关)、目标代码优化(机器相关)

   中间代码优化按范围区分，分为：全局优化、循环优化、基本块局部优化、窥孔优化

2. 常见的优化方法：

   公共子表达式合并

   复制传播：消除一些无用的u = v型的复制语句

   死代码消除：消除一些无用的赋值语句

   代码移动：减少循环内部代码数量等

   常量传播：将一些值为常量的变量用常量代替

   归纳变量和强度消减：在循环中找到与循环同步增长的变量并消减它的相关运算的强度

3. 循环优化

   支配结点：如果任何一条从入口结点到n的路径都经过结点d，那么就说d是n的支配结点，即为d dom n。**支配结点包括结点本身**

   支配结点计算：对于某个结点的所有前驱结点，计算它们的支配结点集合的交集。这个交集并上结点本身就是该结点的支配结点集合

   回边：如果对于边a->b，满足b dom a，则称该边为回边。

   循环定义：具有单一入口结点的强连通图

   自然循环性质：具有唯一入口结点、强连通图、存在一条进入循环入口的回边、由一个结点集合进行描述

   根据回边计算循环

   <img src="C:\Users\pentakill\AppData\Roaming\Typora\typora-user-images\image-20220624173622238.png" alt="image-20220624173622238" style="zoom:50%;" />

   Reducible flow graph：删除所有回边后不再有循环的图，通过回边可以找到所有的循环

   代码移动优化：找到满足如下要求的代码x = y op z，并将其移出循环

   该代码的运算量都是循环不变量

   循环没有其他语句定义了x的值

   该循环中用到x的语句使用的都是该代码定义的x

   x在循环的出口处没有活性，即后续代码不会使用x

   归纳变量和强度削减：找到循环中的基本归纳变量(i = i + C)，并得到与该基本归纳变量相关的归纳变量族(j = i\*C1 + C2)，将j的运算削减成加减法，并尝试用j代替i使得i的计算代码变为死代码被消除(可以回顾PPT中的例子)

4. 数据流分析

   程序点：除了开始和结束指令之外，每两条语句之间都有一个程序点，表示程序运行到这个位置时的状态。每个基本块的开头和结尾都有一个程序点

   可达性：定义d可达程序点p当且仅当存在一条从d到p的路径，在这条路径上没有其他对d定义的变量赋值的语句

   ud-chain：可以到达语句s的变量x定义的所有位置

   du-chain：某个语句定义的变量x可达的所有位置

   IN[s]和OUT[s]函数：数据流问题采用到的数据流值，对于不同的数据流应用，这两个函数计算得到的值不同，它们计算的是语句s之前和之后的数据流值。函数也可以应用在基本块上，通过块内各语句的传递函数结果组合起来获得，代表了基本块开始和结束时的数据流值

   数据流分析的具体应用详见PPT

   

   